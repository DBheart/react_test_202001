# 컴포넌트 분리의정석

## 코드상의 컴포넌트 분리 확인
컴포넌트는 코드상으로 2개로 분리된다.
1. 클래스형 컴포넌트
2. 함수형 컴포넌트

그러면 둘중에 무엇을 써야하는가? 많은 사람들이 class를 우선적으로 쓴다.
하지만 React에서 권장하기는 함수형을 주로 쓰라고 한다.
- 사람들이 클래스형을 주로쓰는것은 특정 제약이 없어서이며, 당장 코딩하기에 좋기 때문이다. 
- 리액트좀 한다는 사람이 함수형을 쓰라고 하는 이유는 분리를 위해서 타당하기 때문이며, 
사람들이 다른곳에서는 쓰지 못하게 클래스형에서 뻘짓하는것을 못하기 때문이다.

## 재사용과 재사용 불가능에 따른 컴포넌트 확인
컴포넌트를 의미상으로 분리하라고 하면 나는 아래와 같이 분리를 우선 할것이다.
1. 재사용 불가능 컴포넌트
    1. 레이아웃을 사용하는 page 속성의 컴포넌트
    2. state와 이벤트를 적용한 컨테이너 컴포넌트
2. 재사용 가능한 컴포넌트
    1. 레이아웃 컴포넌트
    2. html요소 컴포넌트
    3. 공통 컴포넌트

- 재미난 사실은 함수형은 대부분이 재사용이 가능하고, 클래스형은 재사용이 불가능하다는 것입니다.
- 재사용 불가능한것은 주로 state와 이벤트가 그곳에 메여 있기 때문입니다.
- 재사용 가능한 것은 직접 state와 이벤트를 직접 다루지 않아서 가능한 경우가 많다.
- Hook이 나오기 이전에는 재사용 불가능 컴포넌트는 클래스형으로 주로 다루었는데 이제는 함수형으로도 가능할 것 같습니다.

여기에 한가지 요소를 더 하면 좀더 쉽게 다가갈수 있다. 바로 atomic pattern입니다.
atomic pattern을 살펴보니 재미난 사실이 있습니다. 모두~ 재사용 가능한 컴포넌트라는 사실입니다.

## 리액트 다음의 컴포넌트와 state사용
다음은 리액트 다음을 위한 컴포넌트와 state를 정하는 것입니다.
- https://ko.reactjs.org/docs/thinking-in-react.html
1. 단일 책임 원칙을 사용한 컴포넌트 분리
2. 단방향 데이터 흐름을 사용한 컴포넌트 코딩
3. 중복 배체 원칙을 사용하여 최소한의 state를 찾아내기
    1. 데이터 목록을 뽑는다.
    2. 다음 원칙하에 state를 찾는다.
        1. 부모로부터 props를 통해 전달됩니까? 그러면 확실히 state가 아닙니다.
        2. 시간이 지나도 변하지 않나요? 그러면 확실히 state가 아닙니다.
        3. 컴포넌트 안의 다른 state나 props를 가지고 계산 가능한가요? 그렇다면 state가 아닙니다.
4. state배치, 컨테이너 컴포넌트 or 레이아웃 컴포넌트
5. 이벤트의 배치, 컨테이너 컴포넌트에 몰아주기

> state는 사용자가 입력한 값과 변하는 값만을 가지고 있어야합니다.
>> 그중에서 제일 애매한것은 상세/팝업의 값일 것입니다. 그래도 위의 원칙을 적용하면 몇가지가 걸러지는 것 같네요. 중복된 값은 props로 쓸수 있게 하고, 나머지 값은 
>>> state중에서 제일 안쓰지 말아야할 것이 리스트 목록같습니다.

리액트 사용할때 최대한 자재해달라는 형식
1. 상속
2. Ref 속성
   - Ref를 사용하면 단방향이 아닌 양방향의 기분을 느낄수도 있습니다.

## 컴포넌트의 분리

1. 리액트다움을 통해서 컴포넌트와 state를 갈라냅니다.
2. atomic pattern으로 재사용가능한 것을 분리해 냅니다.
3. state를 중앙관리할 것인지 정합니다.

분리하는 법
1. html태그 요소를 atomic의 Atoms로 구현해 냅니다.
    - input~ 캘린더까지
    - 해당요소는 라이브러리를 reform을 하면 좋습니다.
        - 여기저기 이름이 다르고 효과가 다른것을 통일해 봅니다.
1. 개발할 뚫어져라 처다봅니다.
2. 레이아웃부분을 atomic의 Templates로 분리합니다.
3. Templates를 가지고 atomic의 Pages로 구현 합니다.
    - Pages를 컨테이너로 써도 될것으로 보입니다.
    - Pages의 경우 계속 추가 되는 부분이므로 저는 따로 두기를 희망해 봅니다.
4. 모가 남았을까요? atomic의 Molecules와 Organisms가 남아있습니다.
    - Melecules의 경우 Label과 Input을 주로 붙여서 쓰죠? 그것이 Melecules요소가 됩니다.
    - Oraganisms는 검색창이 다른곳에서도 똑같은 컴포넌트들로 구성되어 있나요? 그것을 공통화 시키면 됩니다.
5. 한가지 더 남아있습니다.
    - 상세와 팝업입니다.
    - 상세의 경우 Pages에 같이 씁니다.
    - 팝업중에서 `업부팝업-공통사용`의 경우 따로 빼놓아야 합니다.

## 결론
src
    - components
        - atomic
            - html태그.js
        - templates
            - 검색어+그리드레이아웃.js
        - melecules
            - 검색어컴포넌트.js
        - oraganisms
            - 공통팝업.js
    - pages
        - common
            - 업무1
                - 모델폴더
                - 업무공통팝업.js
            - 업무2
        - 페이지명
            - 페이지명.js        
            - 모델폴더
                - 모델(or store or reducer or modules).js
            - 하위
                - 상세1.js
                - 상세2.js
    - utils
        - utils1.js

* pages > common을 직무? 컴포넌트로 두어도 괜찮을것 같습니다.
* 모델이라는 것을 따로 만들고 싶은데 아직은 요원하네요.
    - 조회 데이터형식을 여기다가 두는 겁니다.
